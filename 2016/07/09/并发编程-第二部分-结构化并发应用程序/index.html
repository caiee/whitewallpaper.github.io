<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Concurrent," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="任务执行围绕 “ 任务执行 “ 构造并发应用程序：任务通常是一些抽象的且离散的工作单元，可分解为多个任务， 简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性
在线程中执行任务在设计结构时，先清晰的找出任务边界。各个任务之间相互独立，不依赖于其他任务的状态、结果或边界效应。独立性有助于实现并发。
正常的负载情况下， 服务器应用程序应该是 良好的">
<meta property="og:type" content="article">
<meta property="og:title" content="并发编程 第二部分 结构化并发应用程序">
<meta property="og:url" content="http://caie.github.io/2016/07/09/并发编程-第二部分-结构化并发应用程序/index.html">
<meta property="og:site_name" content="蔡萼的学习记录">
<meta property="og:description" content="任务执行围绕 “ 任务执行 “ 构造并发应用程序：任务通常是一些抽象的且离散的工作单元，可分解为多个任务， 简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性
在线程中执行任务在设计结构时，先清晰的找出任务边界。各个任务之间相互独立，不依赖于其他任务的状态、结果或边界效应。独立性有助于实现并发。
正常的负载情况下， 服务器应用程序应该是 良好的">
<meta property="og:updated_time" content="2016-07-14T01:53:14.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="并发编程 第二部分 结构化并发应用程序">
<meta name="twitter:description" content="任务执行围绕 “ 任务执行 “ 构造并发应用程序：任务通常是一些抽象的且离散的工作单元，可分解为多个任务， 简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性
在线程中执行任务在设计结构时，先清晰的找出任务边界。各个任务之间相互独立，不依赖于其他任务的状态、结果或边界效应。独立性有助于实现并发。
正常的负载情况下， 服务器应用程序应该是 良好的">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"right","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 6321109203595298000,
      author: '主编大人'
    }
  };
</script>




  <link rel="canonical" href="http://caie.github.io/2016/07/09/并发编程-第二部分-结构化并发应用程序/"/>

  <title> 并发编程 第二部分 结构化并发应用程序 | 蔡萼的学习记录 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">蔡萼的学习记录</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">where notes noting</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                并发编程 第二部分 结构化并发应用程序
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-07-09T16:38:47+08:00" content="2016-07-09">
              2016-07-09
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Concurrent/" itemprop="url" rel="index">
                    <span itemprop="name">Concurrent</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/07/09/并发编程-第二部分-结构化并发应用程序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/07/09/并发编程-第二部分-结构化并发应用程序/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h1><p>围绕 “ <code>任务执行</code> “ 构造并发应用程序：任务通常是一些抽象的且离散的工作单元，<br>可分解为多个任务， 简化程序的组织结构，提供一种自然的事务边界来优化错误恢复过程，以及提供一种自然的并行工作结构来提升并发性</p>
<h2 id="在线程中执行任务"><a href="#在线程中执行任务" class="headerlink" title="在线程中执行任务"></a>在线程中执行任务</h2><p>在设计结构时，先清晰的找出任务边界。<br>各个任务之间相互独立，不依赖于其他任务的状态、结果或边界效应。<br>独立性有助于实现并发。</p>
<p>正常的负载情况下， 服务器应用程序应该是 <code>良好的吞吐量</code> 和 <code>快速的响应性</code> 共存。</p>
<a id="more"></a>
<h3 id="串行地执行任务"><a href="#串行地执行任务" class="headerlink" title="串行地执行任务"></a>串行地执行任务</h3><p>以一个 Socket 监听 80 端口为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleThreadWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Socket connection = socket.accept();</span><br><span class="line">            handleRequest(connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大致如下：</p>
<ul>
<li>每次处理一个请求</li>
<li>主线程在接受连接与处理请求操作中不断交替运行</li>
<li>新的请求必须等待前一个结束</li>
</ul>
<p>有可能堵塞的情况：</p>
<ul>
<li>处理套接字 I/O 读取请求和写回响应， 可能会因为网络拥塞 或 连通性而 阻塞</li>
<li>处理文件I/O 或 数据库请求， 也可能堵塞</li>
<li>单线程堵塞时，资源利用率低，CPU将处于空闲状态</li>
</ul>
<h3 id="显示地为任务创建线程"><a href="#显示地为任务创建线程" class="headerlink" title="显示地为任务创建线程"></a>显示地为任务创建线程</h3><p>将 Socket 监听 改写为 创建线程形式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskWebServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>分离主线程处理任务的过程，使得服务器可以一直接受请求，快速响应(无限制创建线程同时也是缺点)</li>
<li>请求可以并行处理，吞吐量得到提高</li>
</ul>
<h3 id="无限制创建线程的不足"><a href="#无限制创建线程的不足" class="headerlink" title="无限制创建线程的不足"></a>无限制创建线程的不足</h3><p>为 <strong> 每个任务分配一个线程 </strong> 的缺陷</p>
<ul>
<li>线程生命周期开销高<ul>
<li>线程创建需要时间， 需要JVM和操作系统提供一些辅助操作</li>
</ul>
</li>
<li>资源消耗<ul>
<li>活跃的线程会消耗系统资源， 当可运行线程数量多于可用处理器数量时，将有线程将被闲置，占用内存，给垃圾处理器带来压力</li>
</ul>
</li>
<li>稳定性<ul>
<li>在可创建的线程数量上存在一个限制，限制随平台而不同， 受多个因素制约<ul>
<li>JVM 启动参数</li>
<li>Thread 构造函数中请求的栈大小</li>
<li>底层操作系统对线程的限制</li>
</ul>
</li>
<li>过犹不及(在一定的范围内 增加线程 可以 提高系统 吞吐率)</li>
</ul>
</li>
<li>需要限制可创建线程的数量</li>
</ul>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>前面记录了两种情况：</p>
<ul>
<li>串行执行问题为糟糕的 <code>响应性</code> 和 <code>吞吐量</code></li>
<li>“为每个任务分配一个线程” 问题 为 <code>资源管理的复杂性</code></li>
</ul>
<p>java.util.concurrent 提供了 灵活的线程池 作为 Executor框架 的一部分，<br>在Java的类库中， 任务执行的主要抽象不是Thread， 而是 Executor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> 生产者 - 消费者 模式 </strong></p>
<ul>
<li>提交任务 相当于 生产者(生产待完成工作单元)</li>
<li>执行任务 相当于 消费者(执行完这些工作单元)</li>
</ul>
<p>实现生产消费者最简单的设计： 使用Executor</p>
<h3 id="基于-Executor-的-Web-服务器"><a href="#基于-Executor-的-Web-服务器" class="headerlink" title="基于 Executor 的 Web 服务器"></a>基于 Executor 的 Web 服务器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutionWebServer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NTHREADS = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">// 任务线程， 初始化大小， 类型为 fixedThreadPool</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Executor exec = Executor.newFixedThreadPool(NTHREADS);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Socket connection = socket.accept();</span><br><span class="line">            Runnable task = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handleRequest(connection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            exec.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，也可以为 <strong> 每个请求启动一个新线程的Executor </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以 <strong> 以同步方式执行所有任务 </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WithinThreadExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="执行策略"><a href="#执行策略" class="headerlink" title="执行策略"></a>执行策略</h3><p>任务提交 与 执行 解耦。<br><strong> What </strong> | <strong> Where </strong> | <strong> When </strong> | <strong> How </strong></p>
<ul>
<li>哪一个(WHat) 线程中执行任务？</li>
<li>优先级是什么？ (FIFO LIFO)</li>
<li>并发执行的任务是多少？ (How Many)</li>
<li>多少个任务等待执行？ (How Many)</li>
<li>任务个数过多时，怎么办？ 拒绝还是接受？ 拒绝如何提示？ (Which and How)</li>
<li>在执行任务前后 做 什么操作 ？ (What)</li>
</ul>
<blockquote>
<p>new Thread(runnable).start()</p>
</blockquote>
<p>当看到这样的代码，就可以考虑是不是需要用 Executor 来代替了</p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>与工作队列(Work Queue) 密切相关， 是把所有等待执行的任务保存在工作队列中。<br>工作者线程 (Worker Thread) 从工作队列中获取一个任务， 执行任务， 然后返回线程池并等待下一个任务。</p>
<p>优势：</p>
<ul>
<li>重用现有线程 而 不是 创建新线程<ul>
<li>免去线程创建和销毁产生的巨大开销</li>
</ul>
</li>
<li>提高响应性<ul>
<li>请求到达时，线程已存在，不需要线程创建</li>
</ul>
</li>
<li>使处理器保持忙碌状态</li>
<li>适当调整线程池大小，创建足够多的线程</li>
</ul>
<p>Executors 中 创建线程池的 静态工厂方法</p>
<ul>
<li>newFixedThreadPool<ul>
<li>固定长度</li>
</ul>
</li>
<li>newCachedThreadPoll<ul>
<li>可缓存的线程池， 回收</li>
</ul>
</li>
<li>newSingThreadExecutor<ul>
<li>单线程，可以按照某种顺序执行队列中的人物</li>
</ul>
</li>
<li>newScheduledThreadPool</li>
<li>固定长度线程池， 可以以 延迟 或 定时 的方式来执行</li>
</ul>
<p>从 <strong> 为每任务分配一个线程 </strong> 变成 <strong> 基于线程池 </strong><br>有益于应用程序的稳定性： 不会在高负载情况下失败， 服务器不会创建过多线程(有效CPU和内存资源使用)。</p>
<h3 id="Executor-的-生命周期"><a href="#Executor-的-生命周期" class="headerlink" title="Executor 的 生命周期"></a>Executor 的 生命周期</h3><p>分为： 运行、关闭、已终止</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将执行平缓关闭，不再接受新的任务， 等待已提交的任务执行完成(包括那些还未开始执行的任务)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 暴力关闭， 尝试关闭所有运行中的任务， 不再启动队列中尚未开启的任务</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 检测是否已关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 检测是否已经终止</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 等待终止</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> 支持关闭操作的 Web 服务器 </strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleWebServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = ...;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket socket = <span class="keyword">new</span> ServerSocket(<span class="number">80</span>);</span><br><span class="line">        <span class="keyword">while</span> (!exec.isShutdown()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Socket conn = socket.aceept();</span><br><span class="line">                exec.execute(() -&gt; handleRequest(conn));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!exec.isShutdown())</span><br><span class="line">                    log(<span class="string">"task submission rejected"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Socket connection)</span> </span>&#123;</span><br><span class="line">        Request req = readRequest(connection);</span><br><span class="line">        <span class="keyword">if</span> (isShutdownRequest(req))</span><br><span class="line">            stop();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dispatcherRequest(req);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="延迟任务与周期任务"><a href="#延迟任务与周期任务" class="headerlink" title="延迟任务与周期任务"></a>延迟任务与周期任务</h3><p>使用 ScheduledThreadPoolExecutor 来 代替 Timer 进行管理延迟任务。</p>
<p>Timer 会造成 <strong> “ 线程泄露 [Thread Leakage]” </strong> 问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OutOfTime</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Timer timer = <span class="keyword">new</span> Timer();</span><br><span class="line">        time.schedule(<span class="keyword">new</span> ThrowTask(), <span class="number">1</span>);</span><br><span class="line">        SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        timer.schedule(<span class="keyword">new</span> ThrowTask(), <span class="number">1</span>);</span><br><span class="line">        SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThrowTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>缺点：</p>
<ul>
<li>执行时只会创建一个线程， 如果某个执行时间过长， 将破坏其他 Timer Task 的定时精确性</li>
<li>如果抛出一个未检查异常， 将终止定时线程。</li>
</ul>
<h3 id="携带结果的任务-Callable-与-Future"><a href="#携带结果的任务-Callable-与-Future" class="headerlink" title="携带结果的任务 Callable 与 Future"></a>携带结果的任务 Callable 与 Future</h3><p>Runnable 的局限： 无法得到返回值 (方法的返回值是void)， 当我们需要它做了某种操作后得到某个结果时，就有局限性。</p>
<p>Callable 是一种 更好的抽象，它认为主入口点 (call) 为返回一个值，也有可能抛出一个异常。</p>
<p>Future 表示一个任务的生命周期， 并提供了相应的方法来判断是否已经完成或取消， 以及 获取 任务 的结果和 取消任务等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="comment">// 检查是否已取消</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 检查任务是否完成</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取任务结果， 可能抛出一个异常，如果没有执行完毕，则堵塞直到有结果</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, CancellationException</span>;</span><br><span class="line">    <span class="comment">// 在一定时间内获取任务结果</span></span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, CancellationException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="安全发布线程到-Executor"><a href="#安全发布线程到-Executor" class="headerlink" title="安全发布线程到 Executor"></a>安全发布线程到 Executor</h3><p>从Java 6 开始， 可以使用 AbstractExecutorService 中 的 newTaskFor ，<br>从而根据已提交的 Runnable 或 Callale 来控制 Future 的 实例化过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在异构任务并行化中存在的局限"><a href="#在异构任务并行化中存在的局限" class="headerlink" title="在异构任务并行化中存在的局限"></a>在异构任务并行化中存在的局限</h3><p>只有当大量相互独立且同构的任务可以并发进行处理时，才能体现出程序的工作负载分配到多个任务中带来的真正性能提升。</p>
<h3 id="CompletionService-Executor-与-BlockingQueue"><a href="#CompletionService-Executor-与-BlockingQueue" class="headerlink" title="CompletionService : Executor 与 BlockingQueue"></a>CompletionService : Executor 与 BlockingQueue</h3><p>它将 Executor 与 BlockingQueue 功能融合在一起，<br>可以将 Callable 任务 给它，而后通过 take 和 poll 方法来获取完成的结果</p>
<p>一个使用 CompletionService 的 例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService executor;</span><br><span class="line"></span><br><span class="line">    Renderer(ExecutorService executor) &#123; <span class="keyword">this</span>.executor = executor; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">renderPage</span><span class="params">(CharSequence source)</span> </span>&#123;</span><br><span class="line">        List&lt;ImageInfo&gt; info = scanForImageInfo(source);</span><br><span class="line">        CompletionService&lt;ImageData&gt; completionService = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(Executor);</span><br><span class="line">        info.forEach(completionService.submit(() -&gt; imageInfo.downloadImage()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderText(source);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>, n = info.size(); t &lt; n ; t ++) &#123;</span><br><span class="line">        Future&lt;Image&gt; f = completionService.take();</span><br><span class="line">        ImageData imageData = f.get();</span><br><span class="line">        rederImage(imageData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="取消与关闭"><a href="#取消与关闭" class="headerlink" title="取消与关闭"></a>取消与关闭</h1><p>行为良好的软件能很完善地处理失败、关闭和取消等过程。<br>但使任务和线程能安全、快速、可靠地停止下来，不是一件容易的事情。<br>Java没有提供安全终止线程的机制，而是提供了 <strong> 协作机制 </strong> :  中断（Interruption），<br>它是有必要的，因为如果立即停止会使共享的数据结构处于不一致的状态。</p>
<h2 id="任务取消"><a href="#任务取消" class="headerlink" title="任务取消"></a>任务取消</h2><p>取消操作：</p>
<ul>
<li>用户请求取消</li>
<li>有时间限制的操作</li>
<li>应用程序事件</li>
<li>错误</li>
<li>关闭</li>
</ul>
<p>取消策略： How，When，What(如何取消， 何时取消， 取消什么)</p>
<h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>取消时不应该使用那些阻塞方法，如 BlockingQueue.put，<br>会导致 线程阻塞后， 永远的阻塞在那儿，结束不了。</p>
<blockquote>
<p>在 Java 的 API 或 语言规范中， 并没有将中断与任何取消语义关联起来， 但实际上，如果在取消之外的其他操作中使用中断， 那么都是不合适的， 并且很难支撑起更大的应用。</p>
</blockquote>
<p>Thread 的 <strong> 中断方法 </strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中断目标线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="comment">// 返回目标线程的中断状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="comment">// 清楚当前线程的中断状态， 返回它之前的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>调用interrupt并不意味着立即停止目标线程正在进行的工作，而只是传递了请求中断的消息，然后由线程在下一个合适的时刻中断自己(取消点）</p>
</blockquote>
<p>通常，中断是实现取消的最合理方式。</p>
<p>通过中断来取消</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeProducer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;BigInteger&gt; queue;</span><br><span class="line"></span><br><span class="line">    PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BigInteger p = BigInteger.ONE;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted())</span><br><span class="line">                queue.put(p = p.nextProbablePrice());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException consumed) &#123;</span><br><span class="line">            <span class="comment">/* 允许线程退出  */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123; interrupt(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中断策略"><a href="#中断策略" class="headerlink" title="中断策略"></a>中断策略</h3><p>与取消策略一样，要有中断策略。</p>
<p>最合理的中断策略是某种形式的线程级(Thread-Level)取消操作或服务级(Service-Level) 取消操作： 尽快退出，<br>在必要时进行清洗，通知某个所有者该线程已经退出。</p>
<blockquote>
<p>由于每个线程拥有各自的中断策略， 因此除非你知道中断对该线程的含义，否则就不应该中断这个线程。</p>
</blockquote>
<h3 id="响应中断"><a href="#响应中断" class="headerlink" title="响应中断"></a>响应中断</h3><p>在调用可中断的阻塞函数时， 如 Thread.sleep 或 BlockingQueue.put， 有两种实用策略可用于处理 InterruptedException</p>
<ul>
<li>传递异常<ul>
<li>可能在执行某个特定于任务的清除操作之后，从而使你的方法也称为可中断的阻塞方法。</li>
</ul>
</li>
<li>恢复中断状态<ul>
<li>使调用栈中的上层代码能够对其进行处理。</li>
</ul>
</li>
</ul>
<p>将 InterruptedException 传递给调用者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BlockingQueue&lt;Task&gt; queue;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">public</span> Task <span class="title">getNextTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> queue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有实现了线程中断策略的代码才可以屏蔽中断请求。在常规的任务和库代码中都不应该屏蔽中断请求。</p>
<p>在外部线程中安排中断 (不要这么做)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> scheduleExecutorService cancelExec = ...;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r, <span class="keyword">long</span> timeout, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread taskThread = Thread.currentThread();</span><br><span class="line">    cancelExec.schedule(() -&gt; taskThread.interrupt(), timeout, unit);</span><br><span class="line">    r.run;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>破坏：</p>
<ul>
<li>在中断线程之前，应该了解它的中断策略</li>
<li>timedRun 可以从任意一个线程中调用， 因此无法知道这个调用线程的中断策略</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> scheduleExecutorService cancelExec = ...;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RethrowableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> Throwable t;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                r.run();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123; <span class="keyword">this</span>.t = t &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">rethrow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> launderThroable(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RethrowableTask task = <span class="keyword">new</span> RethrowableTask();</span><br><span class="line">    <span class="keyword">final</span> Thread taskThread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">    taskThread.start();</span><br><span class="line">    cancelExec.schedule(() -&gt; taskThread.interrupt(), timeout, unit);</span><br><span class="line">    taskThread.join(unit.toMillis(timeout));</span><br><span class="line">    task.rethrow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过-Future-来实现取消"><a href="#通过-Future-来实现取消" class="headerlink" title="通过 Future 来实现取消"></a>通过 Future 来实现取消</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">timedRun</span><span class="params">(Runnable r, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Futuer&lt;?&gt; task = taskExec.submit(r);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        task.get(timeout, unit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">        <span class="comment">// 接下来任务将被取消</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        <span class="comment">// 如果在任务中抛出了异常， 那么重新抛出该异常</span></span><br><span class="line">        <span class="keyword">throw</span> launderThrowable(e.getCause());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果任务已经结束， 那么执行取消操作也不会带来任何影响</span></span><br><span class="line">        <span class="comment">// 如果任务正在运行， 那么僵被中断</span></span><br><span class="line">        task.cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当 Future.get 抛出 InterruptedException 或 TimeoutException 时， 如果不再需要结果，就可以调用 Future.cancel 来取消任务。</p>
</blockquote>
<h3 id="处理不可中断的阻塞"><a href="#处理不可中断的阻塞" class="headerlink" title="处理不可中断的阻塞"></a>处理不可中断的阻塞</h3><p>不是所有的可阻塞方法或者阻塞机制都能响应中断， 如果一个线程由于执行同步的 Socket I/O 或者等待获得内置锁而阻塞，<br>那么中断请求只能设置线程的中断状态。</p>
<h2 id="停止基于线程的服务"><a href="#停止基于线程的服务" class="headerlink" title="停止基于线程的服务"></a>停止基于线程的服务</h2><p>应用程序通常会创建拥有多个线程的服务， 例如线程池， 这些服务的生命周期通常比创建它们的方法的生命周期更长。</p>
<blockquote>
<p>对于持有线程的服务，只要服务的存在时间大于创建线程的方法的存在时间，那么就应该提供生命周期方法。</p>
</blockquote>
<h3 id="关闭ExecutorService"><a href="#关闭ExecutorService" class="headerlink" title="关闭ExecutorService"></a>关闭ExecutorService</h3><p>使用 ExecutorService 来管理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec = newSingThreadExecutor();</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exec.shutdown(); <span class="comment">// 将 任务 平滑关闭， 等待所有任务完成， 再执行关闭</span></span><br><span class="line">            exec.awaitTermination(TIMEOUT, UNIT); <span class="comment">// 等待一定时长，再检测任务是否已关闭 并返回结果</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writer.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> WriteTask(msg)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException ignored) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-“毒丸”-对象-来关闭"><a href="#使用-“毒丸”-对象-来关闭" class="headerlink" title="使用 “毒丸” 对象 来关闭"></a>使用 “毒丸” 对象 来关闭</h3><p>毒丸： <code>Poison Pill</code><br>当得到这个对象的时候，立即停止。<br>在 <strong> FIFO </strong> 的队列上 与 生产者 消费者 工作模式 上，<br>可以保证消费者消费完队列中所有工作后， 关闭线程。</p>
<h3 id="shutdownNow-的-局限性"><a href="#shutdownNow-的-局限性" class="headerlink" title="shutdownNow 的 局限性"></a>shutdownNow 的 局限性</h3><p>作用： 强行关闭 ExecutorService， 尝试取消正在执行的任务， 并返回所有已提交但尚未开始的任务。<br>缺点： 无法在关闭过程中知道正在执行的任务的状态(哪些已经开始但尚未结束 等等)。</p>
<p>扩展 ExecutorService， 在执行时加判断， 如果被关闭， 则记录到 Set 中， 提供一个获取的方法 返回所有关闭时被取消的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrackingExecutor</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExecutorService exec;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Runnable&gt; tasksCacnelledAtShutdown = Collections.synchronziedSet(<span class="keyword">new</span> HashSet&lt;&gt;());</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">getCancelledTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!exec.isTerminated()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(tasksCacnelledAtShutdown);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable runnable)</span> </span>&#123;</span><br><span class="line">        exec.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                runnable.run();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 如果发现被关闭， 则记录到 Set 集合中</span></span><br><span class="line">                <span class="keyword">if</span> (isShutdown() &amp;&amp; Thread.currentThread().isInterrupted())</span><br><span class="line">                    tasksCacnelledAtShutdown.add(runnable);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Concurrent/" rel="tag">#Concurrent</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/07/02/《并发编程-第-5-章-基础构建模块》读书笔记/" rel="next" title="《并发编程 第 5 章 基础构建模块》读书笔记">
                <i class="fa fa-chevron-left"></i> 《并发编程 第 5 章 基础构建模块》读书笔记
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/07/24/七周七语言-Scala/" rel="prev" title="七周七语言 Scala">
                七周七语言 Scala <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="2016/07/09/并发编程-第二部分-结构化并发应用程序/"
     data-title="并发编程 第二部分 结构化并发应用程序"
     data-content=""
     data-url="http://caie.github.io/2016/07/09/并发编程-第二部分-结构化并发应用程序/">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/07/09/并发编程-第二部分-结构化并发应用程序/"
           data-title="并发编程 第二部分 结构化并发应用程序" data-url="http://caie.github.io/2016/07/09/并发编程-第二部分-结构化并发应用程序/">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/cece.jpeg"
               alt="蔡萼" />
          <p class="site-author-name" itemprop="name">蔡萼</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">16</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/whitewallpaper" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/cai-e-62" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#任务执行"><span class="nav-number">1.</span> <span class="nav-text">任务执行</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#在线程中执行任务"><span class="nav-number">1.1.</span> <span class="nav-text">在线程中执行任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#串行地执行任务"><span class="nav-number">1.1.1.</span> <span class="nav-text">串行地执行任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#显示地为任务创建线程"><span class="nav-number">1.1.2.</span> <span class="nav-text">显示地为任务创建线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#无限制创建线程的不足"><span class="nav-number">1.1.3.</span> <span class="nav-text">无限制创建线程的不足</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Executor框架"><span class="nav-number">1.2.</span> <span class="nav-text">Executor框架</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基于-Executor-的-Web-服务器"><span class="nav-number">1.2.1.</span> <span class="nav-text">基于 Executor 的 Web 服务器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#执行策略"><span class="nav-number">1.2.2.</span> <span class="nav-text">执行策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池"><span class="nav-number">1.2.3.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Executor-的-生命周期"><span class="nav-number">1.2.4.</span> <span class="nav-text">Executor 的 生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#延迟任务与周期任务"><span class="nav-number">1.2.5.</span> <span class="nav-text">延迟任务与周期任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#携带结果的任务-Callable-与-Future"><span class="nav-number">1.2.6.</span> <span class="nav-text">携带结果的任务 Callable 与 Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全发布线程到-Executor"><span class="nav-number">1.2.7.</span> <span class="nav-text">安全发布线程到 Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在异构任务并行化中存在的局限"><span class="nav-number">1.2.8.</span> <span class="nav-text">在异构任务并行化中存在的局限</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CompletionService-Executor-与-BlockingQueue"><span class="nav-number">1.2.9.</span> <span class="nav-text">CompletionService : Executor 与 BlockingQueue</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#取消与关闭"><span class="nav-number">2.</span> <span class="nav-text">取消与关闭</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#任务取消"><span class="nav-number">2.1.</span> <span class="nav-text">任务取消</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#中断"><span class="nav-number">2.1.1.</span> <span class="nav-text">中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断策略"><span class="nav-number">2.1.2.</span> <span class="nav-text">中断策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#响应中断"><span class="nav-number">2.1.3.</span> <span class="nav-text">响应中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过-Future-来实现取消"><span class="nav-number">2.1.4.</span> <span class="nav-text">通过 Future 来实现取消</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理不可中断的阻塞"><span class="nav-number">2.1.5.</span> <span class="nav-text">处理不可中断的阻塞</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#停止基于线程的服务"><span class="nav-number">2.2.</span> <span class="nav-text">停止基于线程的服务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭ExecutorService"><span class="nav-number">2.2.1.</span> <span class="nav-text">关闭ExecutorService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-“毒丸”-对象-来关闭"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用 “毒丸” 对象 来关闭</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#shutdownNow-的-局限性"><span class="nav-number">2.2.3.</span> <span class="nav-text">shutdownNow 的 局限性</span></a></li></ol></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">蔡萼</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ccce"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    <script src="/vendors/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  






  
  

  

  

  

</body>
</html>
